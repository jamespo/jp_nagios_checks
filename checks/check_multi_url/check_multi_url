#!/usr/bin/env python3

# check_multi_url ; -*-Python-*-
# a simple nagios check to validate multiple URLs in parallel using async
# Copyright James Powell 2018 / jamespo [at] gmail [dot] com
# This program is distributed under the terms of the GNU General Public License v3

from collections import namedtuple
import asyncio
import aiohttp
import re
import time
import yaml
import sys
from optparse import OptionParser

# https://pawelmhm.github.io/asyncio/python/aiohttp/2016/04/22/asyncio-aiohttp.html

class MultiCheckOptions():
    '''store the options, default, CLI or from YAML
    priority CLI > YAML > default'''

    def __init__(self):
        self.options = {}
        self.options['timeout'] = 20
        self.options['defaultcheck'] = 'code:200'
        self.get_cli_options()  # update self.options with CLI args


    def get_cli_options(self):
        '''get command line options & return OptionParser'''
        parser = OptionParser()
        parser.add_option("-f", "--runfile", dest="runfile")
        opts, args = parser.parse_args()
        # set object attributes to CLI args
        for opt in [x.dest for x in parser._get_all_options()[1:]]:
            if getattr(opts, opt) is not None:
                self.options[opt] = getattr(opts, opt)


class MultiCheck():
    '''parse yaml, run checks'''

    def __init__(self, mco):
        self.results = []
        self.mco = mco    # MultiCheckOptions
        self.runyaml = self.parse_runfile(mco.options['runfile'])

    @staticmethod
    def parse_runfile(runfile):
        '''parse runfile & create check objects'''
        with open(runfile) as f:
            return yaml.safe_load(f)

    @staticmethod
    def check_result(text, status, url, test):
        '''individually check page result'''
        checktype, checkmatch = test.split(':', 1)
        if checktype == 'code':
            # http status code check
            return int(checkmatch) == int(status)
        elif checktype == 're':
            # regexp match check
            search_res = re.search(checkmatch, text, re.MULTILINE)
            return search_res is not None


    def check_all_results(self):
        '''check if results match tests'''
        # presumes result urls maintain order
        for result, urltest in zip(self.results, self.runyaml['urls']):
            if 'test' not in urltest:
                cr = self.check_result(*result, self.mco.options['defaultcheck'])
            else:
                cr = self.check_result(*result, urltest['test'])
            print(result[2], cr)


    @staticmethod
    async def fetch(url, session):
        '''fetch url async'''
        async with session.get(url) as resp:
            return await resp.text(), resp.status, url


    async def mainloop(self):
        '''create tasks and wait for responses'''
        jar = aiohttp.DummyCookieJar()
        timeout = aiohttp.ClientTimeout(total=self.mco.options['timeout'])
        tasks = []
        async with aiohttp.ClientSession(cookie_jar=jar, \
                                         timeout=timeout) as session:
            for url in [chk['url'] for chk in self.runyaml['urls']]:
                # print("%s - %s", url, time.time())
                tasks.append(asyncio.ensure_future(self.fetch(url, session)))
            self.results = await asyncio.gather(*tasks)


def main():
    '''create options & check objects, run async loop & check results'''
    mco = MultiCheckOptions()
    if mco.options.get('runfile') is None:
        sys.exit('No runfile specified - quitting')
    mc = MultiCheck(mco)
    start_time = float(time.time())
    loop = asyncio.get_event_loop()
    loop.run_until_complete(mc.mainloop())
    mc.check_all_results()
    print('took %.3f seconds' % (time.time() - start_time))


if __name__ == '__main__':
    main()
