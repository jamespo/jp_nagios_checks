#!/usr/bin/env python3

# check_multi_url ; -*-Python-*-
# a simple nagios check to validate multiple URLs in parallel using async
# Copyright James Powell 2018 / jamespo [at] gmail [dot] com
# This program is distributed under the terms of the GNU General Public License v3

from collections import namedtuple
import asyncio
import aiohttp
import re
import time
import yaml
import sys
from optparse import OptionParser

# https://pawelmhm.github.io/asyncio/python/aiohttp/2016/04/22/asyncio-aiohttp.html


class MultiCheckOptions():
    '''store the options, default, CLI or from YAML
    priority CLI > YAML > default'''

    def __init__(self):
        self.options = {}
        self.options['total_timeout'] = 20
        self.options['defaultcheck'] = 'code:200'
        self.get_cli_options()  # update self.options with CLI args
        self.parse_runfile()  # populate self.runfile

    def get_cli_options(self):
        '''get command line options & return OptionParser'''
        parser = OptionParser()

        parser.add_option("-f", "--runfile", dest="runfile")
        opts, args = parser.parse_args()
        # set object attributes to CLI args
        for opt in [x.dest for x in parser._get_all_options()[1:]]:
            if getattr(opts, opt) is not None:
                self.options[opt] = getattr(opts, opt)

    def parse_runfile(self):
        '''parse runfile & create check object'''
        with open(self.options['runfile']) as f:
            self.runfile = yaml.safe_load(f)


class MultiCheck():
    '''take MultiCheckOptions arg, get urls & check them'''

    def __init__(self, mco):
        self.results = []
        self.mco = mco    # MultiCheckOptions

    @staticmethod
    def check_result(text, status, url, req_time, test):
        '''individually check page result'''
        # print(url, req_time)   # DEBUG
        checktype, checkmatch = test.split(':', 1)
        if checktype == 'code':
            # http status code check
            return int(checkmatch) == int(status)
        elif checktype == 're':
            # regexp match check
            search_res = re.search(checkmatch, text, re.MULTILINE)
            return search_res is not None
        elif checktype == 'duration':
            if checkmatch[0] == '<':
                # only less than supported for now
                return float(req_time) < float(checkmatch[1:])
        # unknown check?
        return False

    def check_all_results(self):
        '''check if results match tests'''
        # presumes result urls maintain order
        for result, urltest in zip(self.results, self.mco.runfile['urls']):
            if 'test' not in urltest:
                cr = self.check_result(*result, self.mco.options['defaultcheck'])
            else:
                cr = self.check_result(*result, urltest['test'])
            # update check object with test result & time taken
            urltest['check_ok'] = cr
            urltest['check_duration'] = "%0.3f" % result[3]  # to 3dp
            print(result[2], cr)  # DEBUG
        del self.results          # cleanup
        print(self.mco.runfile)   # DEBUG

    @staticmethod
    async def fetch(url, session):
        '''fetch url async - returns content, http status, url and request time'''
        req_start_time = float(time.time())
        async with session.get(url) as resp:
            return await resp.text(), resp.status, url, time.time() - req_start_time

    async def mainloop(self):
        '''create tasks and wait for responses & update self.results'''
        jar = aiohttp.DummyCookieJar()
        timeout = aiohttp.ClientTimeout(total=self.mco.options['total_timeout'])
        tasks = []
        self.start_time = float(time.time())
        async with aiohttp.ClientSession(cookie_jar=jar,
                                         timeout=timeout) as session:
            for url in [chk['url'] for chk in self.mco.runfile['urls']]:
                tasks.append(asyncio.ensure_future(self.fetch(url, session)))
            self.results = await asyncio.gather(*tasks)
        self.finish_time = float(time.time())


def main():
    '''create options & check objects, run async loop & check results'''
    mco = MultiCheckOptions()
    if mco.options.get('runfile') is None:
        sys.exit('No runfile specified - quitting')
    mc = MultiCheck(mco)
    loop = asyncio.get_event_loop()
    loop.run_until_complete(mc.mainloop())
    mc.check_all_results()
    print('took %.3f seconds' % (mc.finish_time - mc.start_time))


if __name__ == '__main__':
    main()
